from bokeh.layouts import gridplot
from bokeh.plotting import figure, show, helpers
from bokeh.resources import CDN
from bokeh.io import output_notebook, push_notebook
output_notebook(resources=CDN)
from bokeh.models import Range1d, ColumnDataSource
import numpy as np

def task_time_series():
    time_series_fig = figure(title="Task Time Series",
                             tools=["save", "hover", "wheel_zoom", "box_zoom", "pan"],
                             background_fill_color="#FFFFFF", x_range=[0, 1], y_range=[0, 1])

    time_series_source = ColumnDataSource(data=dict(
        left=[],
        right=[],
        top=[]
    ))

    time_series_fig.quad(left='left', right='right', top='top', bottom=0,
                         source=time_series_source, fill_color="#B3B3B3", line_color="#033649")

    time_series_fig.xaxis.axis_label = 'Time in seconds'
    time_series_fig.yaxis.axis_label = 'Number of concurrent tasks'

    handle = show(gridplot(time_series_fig, ncols=1, plot_width=500, plot_height=500, toolbar_location="below"),
         notebook_handle=True)

    def time_series_data(abs_earliest, abs_latest, abs_num_tasks, tasks):
        granularity = 1
        earliest = time.time()
        latest = 0

        for task_id, data in tasks.items():
            if data["score"] > latest:
                latest = data["score"]
            if data["score"] < earliest:
                earliest = data["score"]

        num_buckets = math.ceil((latest - earliest) / granularity)

        buckets = []

        for i in range(0, num_buckets, granularity):
            start = i * granularity + earliest
            end = ((i + 1) * granularity) + earliest
            t = ray.global_state.task_profiles(start=start, end=end)
            buckets.append(len(t))

        if len(buckets) == 0:
            return [], [], []

        distr = []
        for x in range(len(buckets)):
            distr.extend([earliest - abs_earliest + granularity * x] * buckets[x])

        bins = [earliest - abs_earliest + (i - 1) * granularity for i in range(len(buckets) + 2)]
        hist, bin_edges = np.histogram(distr, bins=bins)

        left = bin_edges[:-1]
        right = bin_edges[1:]
        top = hist

        return left, right, top

    def time_series_update(abs_earliest, abs_latest, abs_num_tasks, tasks):
        left, right, top = time_series_data(abs_earliest, abs_latest, abs_num_tasks, tasks)

        time_series_source.data = {'left': left, 'right': right, 'top': top}

        x_range = (max(0, min(left)) if len(left) else 0, max(right) if len(right) else 1)
        y_range = (0, max(top) + 1 if len(top) else 1)

        x_range = helpers._get_range(x_range)
        time_series_fig.x_range.start = x_range.start
        time_series_fig.x_range.end = x_range.end

        y_range = helpers._get_range(y_range)
        time_series_fig.y_range.start = y_range.start
        time_series_fig.y_range.end = y_range.end

        push_notebook(handle=handle)

    get_sliders(time_series_update)

task_time_series()