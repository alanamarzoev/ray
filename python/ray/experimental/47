def dependency_graph(task_id):
    import networkx as nx
    from bokeh.plotting import figure, show
    from bokeh.resources import CDN
    from bokeh.io import output_notebook
    from bokeh.models import CustomJS, ColumnDataSource, Slider, HoverTool, TapTool
    output_notebook( resources=CDN )
    from bokeh.layouts import gridplot

    edges = []
    nodes = set()

    DG = nx.DiGraph()

    import time
    task_profiles = ray.global_state.task_profiles(start=0,end=time.time())
    task_info = ray.global_state.task_table()

    if task_id not in task_info:
        raise ValueError()

    DG.add_node(task_id)

    try:
        while task_id not in nodes:
            nodes.add(task_id)
            parent_id = task_info[task_id]["TaskSpec"]["ParentTaskID"]
            if parent_id not in task_info:
                break
            DG.add_node(parent_id)
            edges.append([task_id, parent_id])
            task_id = parent_id
    except KeyError:
        pass

    DG.add_edges_from(edges)

    from collections import defaultdict
    df = defaultdict(list)
    pts = nx.shell_layout(DG)

    for task_id, indices in pts.items():
        df["x"].append(indices[0])
        df["y"].append(indices[1])
        df["task_id"].append(task_info[task_id]["TaskSpec"]["TaskID"])

        try:
            df["function_name"].append(task_profiles[task_id]["function_name"])
        except KeyError:
            df["function_name"].append("None")

        try:
            df["parent_id"].append(task_info[task_id]["TaskSpec"]["ParentTaskID"])
            df["return_object"].append(list(map(lambda x: x.hex(), task_info[task_id]["TaskSpec"]["ReturnObjectIDs"])))
        except KeyError:
            df["parent_id"].append("None")

    source = ColumnDataSource(data=dict(
        x=[],
        y=[],
        task_id=[],
        parent_id=[],
        function_name=[],
        return_object=[]
    ))
    source.data = dict(
                    x= df["x"],
                    y= df["y"],
                    parent_id=df["parent_id"],
                    task_id=df["task_id"],
                    function_name=df["function_name"],
                    return_object=df["return_object"]
                    )

    hover = HoverTool(tooltips=[
        ("TaskID", "@task_id"),
        ("Function", "@function_name"),
        ("ParentID", "@parent_id"),
        ("Return ObjectID", "@return_object")
    ])

    p = figure(
        x_range=(-5,5),
        y_range=(-5,5),
        height=700,
        width=700,
        tools=[hover,"pan","wheel_zoom","box_zoom", "save", "tap"],
        toolbar_sticky=False
    )

    def callback(task_id=task_id):
        pp = pprint.PrettyPrinter()
        pp.pprint(task_info[task_id])

    taptool = p.select(type=TapTool)
    taptool.callback = CustomJS.from_py_func(callback)

    p.xaxis.visible = False
    p.yaxis.visible = False

    p.line(
        x="x",
        y="y",
        source=source
    )

    p.circle(
    x="x",
    y="y",
    source=source,
    size=40,
    color="blue")

    show(gridplot(p, ncols=1, plot_width=500, plot_height=500, toolbar_location="below"))


task_search = widgets.Text(
    value="",
    placeholder="Task ID",
    description="Search for a task:",
    disabled=False
)
display(task_search)

def handle_submit(sender):
    pp = pprint.PrettyPrinter()
    pp.pprint(ray.global_state.task_table(task_search.value))
    dependency_graph(task_search.value)

task_search.on_submit(handle_submit)